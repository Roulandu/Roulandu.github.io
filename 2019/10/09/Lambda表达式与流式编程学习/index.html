<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Java8 新特性Lambda表达式与流式编程学习 1.Lambda表达式Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。  语法：lambda 表达式的语法格式如下： (parameters) -&amp;gt; expression 或 (p">
<meta property="og:type" content="article">
<meta property="og:title" content="Roulandu的学习记录">
<meta property="og:url" content="http://yoursite.com/2019/10/09/Lambda表达式与流式编程学习/index.html">
<meta property="og:site_name" content="Roulandu的学习记录">
<meta property="og:description" content="Java8 新特性Lambda表达式与流式编程学习 1.Lambda表达式Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。  语法：lambda 表达式的语法格式如下： (parameters) -&amp;gt; expression 或 (p">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/10/09/Lambda表达式与流式编程学习/streamOperation.png">
<meta property="og:updated_time" content="2019-10-09T12:58:38.214Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Roulandu的学习记录">
<meta name="twitter:description" content="Java8 新特性Lambda表达式与流式编程学习 1.Lambda表达式Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。  语法：lambda 表达式的语法格式如下： (parameters) -&amp;gt; expression 或 (p">
<meta name="twitter:image" content="http://yoursite.com/2019/10/09/Lambda表达式与流式编程学习/streamOperation.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/10/09/Lambda表达式与流式编程学习/">





  <title> | Roulandu的学习记录</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Roulandu的学习记录</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/09/Lambda表达式与流式编程学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roulandu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Roulandu的学习记录">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-09T20:53:27+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java8-新特性Lambda表达式与流式编程学习"><a href="#Java8-新特性Lambda表达式与流式编程学习" class="headerlink" title="Java8 新特性Lambda表达式与流式编程学习"></a>Java8 新特性Lambda表达式与流式编程学习</h1><hr>
<h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h2><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>
<hr>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><p>lambda 表达式的语法格式如下：</p>
<pre><code>(parameters) -&gt; expression
或
(parameters) -&gt;{ statements; }</code></pre><p>以下是lambda表达式的重要特征:</p>
<ul>
<li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<hr>
<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p><strong>1.用Lambda表达式()-&gt;{}替代匿名类</strong></p>
<p>针对匿名类，最常见的操作就是对其内部业务逻辑进行实现。由于Java是命令式语言，Java 8之前的所有匿名类代码都是显式的，即显式的对其业务逻辑代码进行编写。通过引入lambda表达式和默认方法，将参数输入简化，并将简单的逻辑代码表示出来。</p>
<p>使用Lambda语法替代实现Runnable接口的匿名类</p>
<pre><code>// Java 8之前：
new Thread(
        new Runnable() {
          @Override
          public void run() {
            System.out.println(&quot;Before Java8&quot;);
          }
        })
    .start();
// Java 8之后：
new Thread(() -&gt; System.out.println(&quot;Now Java8&quot;)).start();</code></pre><p>输出：</p>
<pre><code>Before Java8
Now Java8</code></pre><p>使用Lambda语法替代实现Comparator接口的匿名类</p>
<pre><code>List&lt;Integer&gt; list1 = Arrays.asList(1, 4, 5, 6, 7, 2, 3, 1, 4, 14, 5456, 123, 6345);
List&lt;Integer&gt; list2 = Arrays.asList(1, 4, 5, 6, 7, 2, 3, 1, 4, 14, 5456, 123, 6345);
List&lt;Integer&gt; list3 = Arrays.asList(1, 4, 5, 6, 7, 2, 3, 1, 4, 14, 5456, 123, 6345);
// Java 8之前：
list1.sort(
    new Comparator&lt;Integer&gt;() {
      @Override
      public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
      }
    });
System.out.println(list1);
// Java 8之后：
list2.sort((Integer o1, Integer o2) -&gt; o2.compareTo(o1));
System.out.println(list2);
// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，
list3.sort(Comparator.comparing(Integer::intValue).reversed());
System.out.println(list3);</code></pre><p>输出：</p>
<pre><code>[6345, 5456, 123, 14, 7, 6, 5, 4, 4, 3, 2, 1, 1]
[6345, 5456, 123, 14, 7, 6, 5, 4, 4, 3, 2, 1, 1]
[6345, 5456, 123, 14, 7, 6, 5, 4, 4, 3, 2, 1, 1]</code></pre><p><strong>2.用Lambda表达式进行列表迭代</strong></p>
<p>针对集合类，最常见的操作就是进行迭代，并将业务逻辑应用于各个元素，例如处理订单、交易和事件的列表。由于Java是命令式语言，Java 8之前的所有循环代码都是顺序的，即可以对其元素进行并行化处理。如果想做并行过滤，就需要自己写代码，这并不是那么容易。通过引入lambda表达式和默认方法，将做什么和怎么做的问题分开了，这意味着Java集合现在知道怎样做迭代，并可以在API层面对集合元素进行并行处理。</p>
<pre><code>// Java 8之前：
List&lt;String&gt; features =
    Arrays.asList(&quot;Lambdas&quot;, &quot;Default Method&quot;, &quot;Stream API&quot;, &quot;Date and Time API&quot;);
for (String feature : features) {
  System.out.println(feature);
}
// Java 8之后：
features.forEach(feature -&gt; System.out.println(feature));
// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，
features.forEach(System.out::println);</code></pre><p>输出:</p>
<pre><code>Lambdas
Default Method
Stream API
Date and Time API
Lambdas
Default Method
Stream API
Date and Time API
Lambdas
Default Method
Stream API
Date and Time API</code></pre><p><strong>3.使用lambda表达式和函数式接口Predicate</strong></p>
<p>除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。Predicate接口非常适用于做过滤。</p>
<pre><code>List&lt;String&gt; languages = Arrays.asList(&quot;Java&quot;, &quot;Scala&quot;, &quot;C++&quot;, &quot;Haskell&quot;, &quot;Lisp&quot;);
// Java 8之前：
System.out.println(&quot;Languages which starts with J or length==4:&quot;);
for (String str : languages) {
  if (str.startsWith(&quot;J&quot;) || str.length() == 4) {
    System.out.print(str + &quot; &quot;);
  }
}
System.out.println();
// Java 8之后：
System.out.println(&quot;Languages which starts with J or length==4:&quot;);
Predicate&lt;String&gt; startsWithJ = s -&gt; s.startsWith(&quot;J&quot;);
Predicate&lt;String&gt; lengthEquals4 = s -&gt; s.length() == 4;
doFilter(languages, startsWithJ.or(lengthEquals4));

private static void doFilter(List&lt;String&gt; list, Predicate predicate) {
    for (String l : list) {
          if (predicate.test(l)) {
            System.out.print(l + &quot; &quot;);
          }
    }
  }</code></pre><p>输出：</p>
<pre><code>Languages which starts with J or length==4:
Java Lisp 
Languages which starts with J or length==4:
Java Lisp </code></pre><hr>
<p><strong>完整测试代码如下：</strong></p>
<pre><code>package com.roulandu;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.function.Predicate;

public class LambdaProgram {
  public static void main(String[] args) throws InterruptedException {
    // 用Lambda表达式()-&gt;{}替代匿名类
    testUseLambdaReplaceAnonymousClass1();
    Thread.sleep(2000);
    System.out.println();
    testUseLambdaReplaceAnonymousClass2();
    System.out.println();
    // 用Lambda表达式进行列表迭代
    testUseLambdaForIterator();
    System.out.println();
    // 使用lambda表达式和函数式接口Predicate
    testUsePredicteAndLambda();
  }

  private static void enter() {
    System.out.println(
        &quot;-------- Method &quot;
            + Thread.currentThread().getStackTrace()[2].getMethodName()
            + &quot; running --------&quot;);
  }

  private static void testUseLambdaReplaceAnonymousClass1() {
    enter();
    // Java 8之前：
    new Thread(
            new Runnable() {
              @Override
              public void run() {
                System.out.println(&quot;Before Java8&quot;);
              }
            })
        .start();
    // Java 8之后：
    new Thread(() -&gt; System.out.println(&quot;Now Java8&quot;)).start();
  }

  private static void testUseLambdaReplaceAnonymousClass2() {
    enter();
    List&lt;Integer&gt; list1 = Arrays.asList(1, 4, 5, 6, 7, 2, 3, 1, 4, 14, 5456, 123, 6345);
    List&lt;Integer&gt; list2 = Arrays.asList(1, 4, 5, 6, 7, 2, 3, 1, 4, 14, 5456, 123, 6345);
    List&lt;Integer&gt; list3 = Arrays.asList(1, 4, 5, 6, 7, 2, 3, 1, 4, 14, 5456, 123, 6345);
    // Java 8之前：
    list1.sort(
        new Comparator&lt;Integer&gt;() {
          @Override
          public int compare(Integer o1, Integer o2) {
            return o2.compareTo(o1);
          }
        });
    System.out.println(list1);
    // Java 8之后：
    list2.sort((Integer o1, Integer o2) -&gt; o2.compareTo(o1));
    System.out.println(list2);
    // 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，
    list3.sort(Comparator.comparing(Integer::intValue).reversed());
    System.out.println(list3);
  }

  private static void testUseLambdaForIterator() {
    enter();
    // Java 8之前：
    List&lt;String&gt; features =
        Arrays.asList(&quot;Lambdas&quot;, &quot;Default Method&quot;, &quot;Stream API&quot;, &quot;Date and Time API&quot;);
    for (String feature : features) {
      System.out.println(feature);
    }
    // Java 8之后：
    features.forEach(feature -&gt; System.out.println(feature));
    // 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，
    features.forEach(System.out::println);
  }

  private static void testUsePredicteAndLambda() {
    enter();
    List&lt;String&gt; languages = Arrays.asList(&quot;Java&quot;, &quot;Scala&quot;, &quot;C++&quot;, &quot;Haskell&quot;, &quot;Lisp&quot;);
    // Java 8之前：
    System.out.println(&quot;Languages which starts with J or length==4:&quot;);
    for (String str : languages) {
      if (str.startsWith(&quot;J&quot;) || str.length() == 4) {
        System.out.print(str + &quot; &quot;);
      }
    }
    System.out.println();
    // Java 8之后：
    System.out.println(&quot;Languages which starts with J or length==4:&quot;);
    Predicate&lt;String&gt; startsWithJ = s -&gt; s.startsWith(&quot;J&quot;);
    Predicate&lt;String&gt; lengthEquals4 = s -&gt; s.length() == 4;
    doFilter(languages, startsWithJ.or(lengthEquals4));
  }

  private static void doFilter(List&lt;String&gt; list, Predicate predicate) {
    for (String l : list) {
      if (predicate.test(l)) {
        System.out.print(l + &quot; &quot;);
      }
    }
  }
}</code></pre><hr>
<h2 id="2-流式编程"><a href="#2-流式编程" class="headerlink" title="2.流式编程"></a>2.流式编程</h2><p>JDK8加入了 java.util.stream 包，实现了集合的流式操作，流式操作包括集合的过滤，排序，映射等功能。根据流的操作性，又可以分为 串行流 和 并行流。根据操作返回的结果不同，流式操作又分为中间操作(返回一特定类型的结果)和最终操作(返回流本身)。大大方便了我们对于集合的操作。</p>
<hr>
<p><strong>常用的流操作:</strong></p>
<p><img src="streamOperation.png" alt></p>
<p>根据操作返回结果不同，大致进行一下分类，也就是返回stream的就是中间操作，其他的，返回具体对象的就是最终操作：</p>
<p>中间操作：</p>
<ul>
<li>filter()： 对元素进行过滤</li>
<li>sorted()：对元素排序</li>
<li>map()：元素映射</li>
<li>flatMap(): 将流中的每个值都转成一个个流，然后再将这些流扁平化成为一个流</li>
<li>distinct()：去除重复的元素</li>
<li>limit(): 限制数量，取前几个</li>
<li>skip(): 限制数量，跳过前几个</li>
<li>等等</li>
</ul>
<p>最终操作：</p>
<ul>
<li>allMatch()：检测是否全部都满足指定的参数行为。</li>
<li>anyMatch()：检测是否存在一个或多个满足指定的参数行为。</li>
<li>noneMatch(): 检测是否不存在满足指定行为的元素。</li>
<li>reduce()：把Stream 元素组合起来。</li>
<li>collect()：返回一个新的集合。</li>
<li>count()：找到最小值。</li>
<li>max()：找到最大值。</li>
<li>等等</li>
</ul>
<p>需要注意的是，一般中间操作之后，都是为了进行最终操作，得到我们需要的对象。</p>
<hr>
<p>###<strong>1.中间操作</strong></p>
<p>####<strong>1.1 过滤</strong></p>
<p><strong>filter</strong></p>
<p>filter接受一个谓词Predicate，我们可以通过这个谓词定义筛选条件，在介绍lambda表达式时我们介绍过Predicate是一个函数式接口，其包含一个test(T t)方法，该方法返回boolean。</p>
<pre><code>List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});
System.out.println(list);
// 过滤后生成新集合
List&lt;Integer&gt; newlist = list.stream().filter(a -&gt; a % 2 != 0).collect(Collectors.toList());
System.out.println(&quot;过滤后生成新集合: &quot; + newlist);
// 结合Predicte使用
Predicate&lt;Integer&gt; biggerThan3 = integer -&gt; integer &gt; 3;
Predicate&lt;Integer&gt; isOdd = integer -&gt; integer % 2 != 0;
List&lt;Integer&gt; newlist1 =
    list.stream().filter(biggerThan3.and(isOdd)).collect(Collectors.toList());
System.out.println(&quot;过滤后生成新集合: &quot; + newlist1);
// 相对复杂的操作
Person person1 = new Person(&quot;zhangsan&quot;, 15);
Person person2 = new Person(&quot;lisi&quot;, 24);
Person person3 = new Person(&quot;wangwu&quot;, 43);
List&lt;Person&gt; personList = Arrays.asList(person1, person2, person3);
// 找到名字长大于4，年龄小于30的人形成一个新列表
Predicate&lt;String&gt; nameLengthLongerThan4 = s -&gt; s.length() &gt; 4;
Predicate&lt;Integer&gt; ageLowerThan30 = integer -&gt; integer &lt; 30;
List&lt;Person&gt; personList1 =
    personList.stream()
        .filter(
            person -&gt;
                nameLengthLongerThan4.test(person.name) &amp;&amp; ageLowerThan30.test(person.age))
        .collect(Collectors.toList());
List&lt;String&gt; names = personList1.stream().map(Person::getName).collect(Collectors.toList());
System.out.println(&quot;过滤后生成新人类集合的名字是: &quot; + names);
List&lt;Integer&gt; ages = personList1.stream().map(Person::getAge).collect(Collectors.toList());
System.out.println(&quot;过滤后生成新人类集合的年龄是: &quot; + ages);

class Person {
  String name;
  Integer age;

  public Person(String name, Integer age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return this.name;
  }

  public Integer getAge() {
    return this.age;
  }
}</code></pre><p>输出：</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
过滤后生成新集合: [1, 3, 5, 7, 9, 11]
过滤后生成新集合: [5, 7, 9, 11]
过滤后生成新人类集合的名字是: [zhangsan]
过滤后生成新人类集合的年龄是: [15]</code></pre><p><strong>distinct</strong></p>
<p>distinct操作类似于我们在写SQL语句时，添加的DISTINCT关键字，用于去重处理。</p>
<pre><code>List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12});
System.out.println(list);
List&lt;Integer&gt; newlist = list.stream().distinct().collect(Collectors.toList());
System.out.println(newlist);</code></pre><p>输出：</p>
<pre><code>[1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12]
[1, 2, 4, 6, 5, 10, 12]</code></pre><p><strong>limit</strong></p>
<p>limit操作也类似于SQL语句中的LIMIT关键字，不过相对功能较弱，limit返回包含前n个元素的流，当集合大小小于n时，则返回实际长度</p>
<pre><code>List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12});
System.out.println(list);
List&lt;Integer&gt; newlist = list.stream().limit(2).collect(Collectors.toList());
System.out.println(newlist);</code></pre><p>输出：</p>
<pre><code>[1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12]
[1, 2]</code></pre><p><strong>skip</strong></p>
<p>skip操作与limit操作相反，如同其字面意思一样，是跳过前n个元素</p>
<pre><code>List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12});
System.out.println(list);
List&lt;Integer&gt; newlist = list.stream().skip(2).collect(Collectors.toList());
System.out.println(newlist);</code></pre><p>输出：</p>
<pre><code>[1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12]
[2, 4, 4, 6, 5, 6, 6, 10, 12, 12]</code></pre><p>####<strong>1.2 映射</strong></p>
<p><strong>map</strong><br>在SQL中，借助SELECT关键字后面添加需要的字段名称，可以仅输出我们需要的字段数据，而流式处理的映射操作也是实现这一目的。</p>
<pre><code>List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});
System.out.println(list);
List&lt;String&gt; newlist = list.stream().map(a -&gt; a.toString()).collect(Collectors.toList());
System.out.println(&quot;map后生成新集合: &quot; + newlist);
// 求和
Integer sum = list.stream().mapToInt(a -&gt; a + 2 * a).sum();
System.out.println(&quot;map后求和: &quot; + sum);
// 求平均值
double avg = list.stream().mapToInt(a -&gt; a + 2 * a).average().getAsDouble();
System.out.println(&quot;map后求均值: &quot; + avg);
// 求平均值
long count = list.stream().mapToInt(a -&gt; a + 2 * a).count();
System.out.println(&quot;map后元素个数: &quot; + count);</code></pre><p>输出：</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
map后生成新集合: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
map后求和: 234
map后求均值: 19.5
map后元素个数: 12</code></pre><p><strong>flatmap</strong><br>flatMap与map的区别在于 flatMap是将一个流中的每个值都转成一个个流，然后再将这些流扁平化成为一个流。</p>
<pre><code>String[] strs = {&quot;java8&quot;, &quot;is&quot;, &quot;easy&quot;, &quot;to&quot;, &quot;use&quot;};
System.out.println(Arrays.asList(strs));
List&lt;String&gt; distinctStrs =
    Arrays.stream(strs)
        .map(str -&gt; str.split(&quot;&quot;)) // 映射成为Stream&lt;String[]&gt;
        .flatMap(Arrays::stream) // 扁平化为Stream&lt;String&gt;
        .distinct()
        .collect(Collectors.toList());
System.out.println(distinctStrs);</code></pre><p>输出:</p>
<pre><code>[java8, is, easy, to, use]
[j, a, v, 8, i, s, e, y, t, o, u]</code></pre><p>###<strong>2.终端操作</strong><br>####<strong>2.1 查找</strong><br><strong>allMatch</strong><br>allMatch用于检测是否全部都满足指定的参数行为，如果全部满足则返回true。<br><strong>anyMatch</strong><br>anyMatch则是检测是否存在一个或多个满足指定的参数行为，如果满足则返回true<br><strong>noneMathch</strong><br>noneMathch用于检测是否不存在满足指定行为的元素，如果不存在则返回true<br><strong>findFirst</strong><br>findFirst用于返回满足条件的第一个元素<br><strong>findAny</strong><br>findAny相对于findFirst的区别在于，findAny不一定返回第一个，而是返回任意一个</p>
<pre><code>List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12});
System.out.println(list);
boolean allMatch = list.stream().filter(a -&gt; a &gt; 3).allMatch(a -&gt; a % 2 == 0);
System.out.println(allMatch);
boolean anyMatch = list.stream().filter(a -&gt; a &gt; 3).anyMatch(a -&gt; a % 2 == 0);
System.out.println(anyMatch);
boolean noneMatch = list.stream().filter(a -&gt; a &gt; 3).noneMatch(a -&gt; a % 2 == 0);
System.out.println(noneMatch);
Integer first = list.stream().filter(a -&gt; a &gt; 3).findFirst().get();
System.out.println(first);
Integer any = list.stream().filter(a -&gt; a &gt; 3).findAny().get();
System.out.println(any);</code></pre><p>输出：</p>
<pre><code>[1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12]
false
true
false
4
4</code></pre><p>实际上对于顺序流式处理而言，findFirst和findAny返回的结果是一样的，至于为什么会这样设计，是因为在启用并行流式处理的时候，查找第一个元素往往会有很多限制，如果不是特别需求，在并行流式处理中使用findAny的性能要比findFirst好。</p>
<p>####<strong>2.2 归约</strong><br>前面的例子中我们大部分都是通过collect(Collectors.toList())对数据封装返回，如我的目标不是返回一个新的集合，而是希望对经过参数化操作后的集合进行进一步的运算，那么我们可用对集合实施归约操作。java8的流式处理提供了reduce方法来达到这一目的。</p>
<pre><code>List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});
System.out.println(list);
operation();
// 求和
Integer sum = list.stream().mapToInt(a -&gt; a + 2 * a).reduce(0, (s, a) -&gt; s + a);
System.out.println(&quot;map后求和: &quot; + sum);
// 简化
Integer sum1 = list.stream().mapToInt(a -&gt; a + 2 * a).reduce(0, Integer::sum);
System.out.println(&quot;map后求和: &quot; + sum1);
OptionalInt sum2 = list.stream().mapToInt(a -&gt; a + 2 * a).reduce(Integer::sum);
System.out.println(&quot;map后求和: &quot; + sum2.getAsInt());</code></pre><p>输出：</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
map后求和: 234
map后求和: 234
map后求和: 234</code></pre><p>####<strong>2.3 收集</strong><br>前面利用collect(Collectors.toList())是一个简单的收集操作，是对处理结果的封装，对应的还有toSet、toMap，以满足我们对于结果组织的需求。这些方法均来自于java.util.stream.Collectors，我们可以称之为收集器。</p>
<p><strong>规约</strong></p>
<p>收集器也提供了相应的归约操作，但是与reduce在内部实现上是有区别的，收集器更加适用于可变容器上的归约操作，这些收集器广义上均基于Collectors.reducing()实现。</p>
<pre><code>List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});
System.out.println(list);
// 求元素总数
Long count = list.stream().collect(Collectors.counting());
System.out.println(count);
// 求最大最小值
Optional&lt;Integer&gt; max =
    list.stream().collect(Collectors.maxBy(Comparator.comparingInt(Integer::intValue)));
Optional&lt;Integer&gt; min =
    list.stream().collect(Collectors.minBy(Comparator.comparingInt(Integer::intValue)));
System.out.println(max.get());
System.out.println(min.get());
// 求和
Integer sum = list.stream().collect(Collectors.summingInt(Integer::intValue));
System.out.println(sum);
// 求平均值
Double avg = list.stream().collect(Collectors.averagingDouble(Integer::intValue));
System.out.println(avg);
// 一次性求上面的集合
IntSummaryStatistics statistics =
    list.stream().collect(Collectors.summarizingInt(Integer::intValue));
System.out.println(statistics.toString());
// 字符串拼接
String str = list.stream().map(a -&gt; a.toString()).collect(Collectors.joining(&quot;--&quot;));
System.out.println(str);</code></pre><p>输出：</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
12
12
1
78
6.5
IntSummaryStatistics{count=12, sum=78, min=1, average=6.500000, max=12}
1--2--3--4--5--6--7--8--9--10--11--12</code></pre><p><strong>分组</strong></p>
<p>在数据库操作中，我们可以通过GROUP BY关键字对查询到的数据进行分组，java8的流式处理也为我们提供了这样的功能Collectors.groupingBy来操作集合。</p>
<pre><code>Person person1 = new Person(&quot;zhangsan&quot;, 15);
Person person2 = new Person(&quot;zhangsan&quot;, 24);
Person person3 = new Person(&quot;zhangsan&quot;, 42);
Person person4 = new Person(&quot;lisi&quot;, 15);
Person person5 = new Person(&quot;wangwu&quot;, 42);
Person person6 = new Person(&quot;wangwu&quot;, 15);
Person person7 = new Person(&quot;chenliu&quot;, 24);
Person person8 = new Person(&quot;chenliu&quot;, 24);
Person person9 = new Person(&quot;zhaoqi&quot;, 42);
List&lt;Person&gt; personList =
    Arrays.asList(
        person1, person2, person3, person4, person5, person6, person7, person8, person9);
Map&lt;String, List&lt;Person&gt;&gt; groupByName =
    personList.stream().collect(Collectors.groupingBy(Person::getName));
System.out.println(groupByName.keySet().stream().collect(Collectors.joining(&quot;,&quot;)));
Map&lt;String, Long&gt; groupByNameThenCount =
    personList.stream().collect(Collectors.groupingBy(Person::getName, Collectors.counting()));
System.out.println(groupByNameThenCount.keySet().stream().collect(Collectors.joining(&quot;,&quot;)));
System.out.println(
    groupByNameThenCount.entrySet().stream()
        .map(a -&gt; a.getValue().toString())
        .collect(Collectors.joining(&quot;,&quot;)));</code></pre><p>输出：<br>    lisi,zhaoqi,zhangsan,chenliu,wangwu<br>    lisi,zhaoqi,zhangsan,chenliu,wangwu<br>    1,1,3,2,2</p>
<p><strong>分区</strong></p>
<p>分区可以看做是分组的一种特殊情况，在分区中key只有两种情况：true或false，目的是将待分区集合按照条件一分为二，java8的流式处理利用ollectors.partitioningBy()方法实现分区，该方法接收一个谓词，例如我们希望将数组分为奇数和偶数，那么可以实现如下：</p>
<pre><code>List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});
System.out.println(list);
operation();
Map&lt;Boolean, List&lt;Integer&gt;&gt; newList =
    list.stream().collect(Collectors.partitioningBy(a -&gt; a % 2 == 0));
System.out.println(newList.get(true));
System.out.println(newList.get(false));</code></pre><p>输出：<br>    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]<br>    [2, 4, 6, 8, 10, 12]<br>    [1, 3, 5, 7, 9, 11]</p>
<hr>
<p><strong>完整测试代码如下：</strong></p>
<pre><code>package com.roulandu;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class StreamProgram {
  public static void main(String[] args) {
    // 中间操作
    // 用于过滤操作
    testStreamOperationFilter();
    System.out.println();
    // 用于排序
    testStreamOperationSorted();
    System.out.println();
    // 去重
    testStreamOperationDistinct();
    System.out.println();
    // limit
    testStreamOperationLimit();
    System.out.println();
    // skip
    testStreamOperationSkip();
    // 用于生成新的集合等
    testStreamOperationMap();
    System.out.println();
    testStreamOperationFlatMap();
    System.out.println();

    // 终端操作
    // findAndMatch
    testStreamOperationFindAndMatch();
    System.out.println();
    // reduce
    testStreamOperationReduce();
    System.out.println();
    // collectorsReduce
    testStreamOperationCollectorsReduce();
    System.out.println();
    // group分组操作
    testStreamOperationCollectorsGroup();
    System.out.println();
    // partition分区操作
    testStreamOperationCollectorsPartition();
  }

  private static void testStreamOperationCollectorsPartition() {
    before();
    List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});
    System.out.println(list);
    operation();
    Map&lt;Boolean, List&lt;Integer&gt;&gt; newList =
        list.stream().collect(Collectors.partitioningBy(a -&gt; a % 2 == 0));
    System.out.println(newList.get(true));
    System.out.println(newList.get(false));
    after();
  }

  private static void testStreamOperationCollectorsGroup() {
    before();
    Person person1 = new Person(&quot;zhangsan&quot;, 15);
    Person person2 = new Person(&quot;zhangsan&quot;, 24);
    Person person3 = new Person(&quot;zhangsan&quot;, 42);
    Person person4 = new Person(&quot;lisi&quot;, 15);
    Person person5 = new Person(&quot;wangwu&quot;, 42);
    Person person6 = new Person(&quot;wangwu&quot;, 15);
    Person person7 = new Person(&quot;chenliu&quot;, 24);
    Person person8 = new Person(&quot;chenliu&quot;, 24);
    Person person9 = new Person(&quot;zhaoqi&quot;, 42);
    List&lt;Person&gt; personList =
        Arrays.asList(
            person1, person2, person3, person4, person5, person6, person7, person8, person9);
    operation();
    Map&lt;String, List&lt;Person&gt;&gt; groupByName =
        personList.stream().collect(Collectors.groupingBy(Person::getName));
    System.out.println(groupByName.keySet().stream().collect(Collectors.joining(&quot;,&quot;)));
    Map&lt;String, Long&gt; groupByNameThenCount =
        personList.stream().collect(Collectors.groupingBy(Person::getName, Collectors.counting()));
    System.out.println(groupByNameThenCount.keySet().stream().collect(Collectors.joining(&quot;,&quot;)));
    System.out.println(
        groupByNameThenCount.entrySet().stream()
            .map(a -&gt; a.getValue().toString())
            .collect(Collectors.joining(&quot;,&quot;)));
    after();
  }

  private static void before() {
    System.out.println(
        &quot;-------- Method &quot;
            + Thread.currentThread().getStackTrace()[2].getMethodName()
            + &quot; start --------&quot;);
  }

  private static void after() {
    System.out.println(
        &quot;-------- Method &quot;
            + Thread.currentThread().getStackTrace()[2].getMethodName()
            + &quot; end --------&quot;);
  }

  private static void operation() {
    System.out.println(
        &quot;-------- Method &quot;
            + Thread.currentThread().getStackTrace()[2].getMethodName()
            + &quot; running --------&quot;);
  }

  private static void testStreamOperationCollectorsReduce() {
    before();
    List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});
    System.out.println(list);
    operation();
    // 求元素总数
    Long count = list.stream().collect(Collectors.counting());
    System.out.println(count);
    // 求最大最小值
    Optional&lt;Integer&gt; max =
        list.stream().collect(Collectors.maxBy(Comparator.comparingInt(Integer::intValue)));
    Optional&lt;Integer&gt; min =
        list.stream().collect(Collectors.minBy(Comparator.comparingInt(Integer::intValue)));
    System.out.println(max.get());
    System.out.println(min.get());
    // 求和
    Integer sum = list.stream().collect(Collectors.summingInt(Integer::intValue));
    System.out.println(sum);
    // 求平均值
    Double avg = list.stream().collect(Collectors.averagingDouble(Integer::intValue));
    System.out.println(avg);
    // 一次性求上面的集合
    IntSummaryStatistics statistics =
        list.stream().collect(Collectors.summarizingInt(Integer::intValue));
    System.out.println(statistics.toString());
    // 字符串拼接
    String str = list.stream().map(a -&gt; a.toString()).collect(Collectors.joining(&quot;--&quot;));
    System.out.println(str);
    after();
  }

  private static void testStreamOperationReduce() {
    before();
    List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});
    System.out.println(list);
    operation();
    // 求和
    Integer sum = list.stream().mapToInt(a -&gt; a + 2 * a).reduce(0, (s, a) -&gt; s + a);
    System.out.println(&quot;map后求和: &quot; + sum);
    // 简化
    Integer sum1 = list.stream().mapToInt(a -&gt; a + 2 * a).reduce(0, Integer::sum);
    System.out.println(&quot;map后求和: &quot; + sum1);
    // 再简化
    OptionalInt sum2 = list.stream().mapToInt(a -&gt; a + 2 * a).reduce(Integer::sum);
    System.out.println(&quot;map后求和: &quot; + sum2.getAsInt());
    after();
  }

  private static void testStreamOperationFindAndMatch() {
    before();
    List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12});
    System.out.println(list);
    operation();
    boolean allMatch = list.stream().filter(a -&gt; a &gt; 3).allMatch(a -&gt; a % 2 == 0);
    System.out.println(allMatch);
    boolean anyMatch = list.stream().filter(a -&gt; a &gt; 3).anyMatch(a -&gt; a % 2 == 0);
    System.out.println(anyMatch);
    boolean noneMatch = list.stream().filter(a -&gt; a &gt; 3).noneMatch(a -&gt; a % 2 == 0);
    System.out.println(noneMatch);
    Integer first = list.stream().filter(a -&gt; a &gt; 3).findFirst().get();
    System.out.println(first);
    Integer any = list.stream().filter(a -&gt; a &gt; 3).findAny().get();
    System.out.println(any);
    after();
  }

  private static void testStreamOperationFlatMap() {
    before();
    String[] strs = {&quot;java8&quot;, &quot;is&quot;, &quot;easy&quot;, &quot;to&quot;, &quot;use&quot;};
    System.out.println(Arrays.asList(strs));
    operation();
    List&lt;String&gt; distinctStrs =
        Arrays.stream(strs)
            .map(str -&gt; str.split(&quot;&quot;)) // 映射成为Stream&lt;String[]&gt;
            .flatMap(Arrays::stream) // 扁平化为Stream&lt;String&gt;
            .distinct()
            .collect(Collectors.toList());
    System.out.println(distinctStrs);
    after();
  }

  private static void testStreamOperationSkip() {
    before();
    List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12});
    System.out.println(list);
    operation();
    List&lt;Integer&gt; newlist = list.stream().skip(2).collect(Collectors.toList());
    System.out.println(newlist);
    after();
  }

  private static void testStreamOperationLimit() {
    before();
    List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12});
    System.out.println(list);
    operation();
    List&lt;Integer&gt; newlist = list.stream().limit(2).collect(Collectors.toList());
    System.out.println(newlist);
    after();
  }

  private static void testStreamOperationDistinct() {
    before();
    List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 2, 4, 4, 6, 5, 6, 6, 10, 12, 12});
    System.out.println(list);
    operation();
    List&lt;Integer&gt; newlist = list.stream().distinct().collect(Collectors.toList());
    System.out.println(newlist);
    after();
  }

  private static void testStreamOperationMap() {
    before();
    List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});
    System.out.println(list);
    operation();
    List&lt;String&gt; newlist = list.stream().map(a -&gt; a.toString()).collect(Collectors.toList());
    System.out.println(&quot;map后生成新集合: &quot; + newlist);
    // 求和
    Integer sum = list.stream().mapToInt(a -&gt; a + 2 * a).sum();
    System.out.println(&quot;map后求和: &quot; + sum);
    // 求平均值
    double avg = list.stream().mapToInt(a -&gt; a + 2 * a).average().getAsDouble();
    System.out.println(&quot;map后求均值: &quot; + avg);
    // 求平均值
    long count = list.stream().mapToInt(a -&gt; a + 2 * a).count();
    System.out.println(&quot;map后元素个数: &quot; + count);
    after();
  }

  private static void testStreamOperationSorted() {
    before();
    List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 3, 2, 4, 5, 7, 9, 8, 6, 10, 12, 11});
    System.out.println(list);
    operation();
    List&lt;Integer&gt; newlist1 = list.stream().sorted().collect(Collectors.toList());
    System.out.println(newlist1);
    operation();
    List&lt;Integer&gt; newlist2 =
        list.stream()
            .sorted(Comparator.comparing(Integer::intValue).reversed())
            .collect(Collectors.toList());
    System.out.println(newlist2);
    after();
  }

  private static void testStreamOperationFilter() {
    before();
    List&lt;Integer&gt; list = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});
    System.out.println(list);
    operation();
    // 过滤后生成新集合
    List&lt;Integer&gt; newlist = list.stream().filter(a -&gt; a % 2 != 0).collect(Collectors.toList());
    System.out.println(&quot;过滤后生成新集合: &quot; + newlist);
    // 结合Predicte使用
    Predicate&lt;Integer&gt; biggerThan3 = integer -&gt; integer &gt; 3;
    Predicate&lt;Integer&gt; isOdd = integer -&gt; integer % 2 != 0;
    List&lt;Integer&gt; newlist1 =
        list.stream().filter(biggerThan3.and(isOdd)).collect(Collectors.toList());
    System.out.println(&quot;过滤后生成新集合: &quot; + newlist1);
    // 相对复杂的操作
    Person person1 = new Person(&quot;zhangsan&quot;, 15);
    Person person2 = new Person(&quot;lisi&quot;, 24);
    Person person3 = new Person(&quot;wangwu&quot;, 43);
    List&lt;Person&gt; personList = Arrays.asList(person1, person2, person3);
    // 找到名字长大于4，年龄小于30的人形成一个新列表
    Predicate&lt;String&gt; nameLengthLongerThan4 = s -&gt; s.length() &gt; 4;
    Predicate&lt;Integer&gt; ageLowerThan30 = integer -&gt; integer &lt; 30;
    List&lt;Person&gt; personList1 =
        personList.stream()
            .filter(
                person -&gt;
                    nameLengthLongerThan4.test(person.name) &amp;&amp; ageLowerThan30.test(person.age))
            .collect(Collectors.toList());
    List&lt;String&gt; names = personList1.stream().map(Person::getName).collect(Collectors.toList());
    System.out.println(&quot;过滤后生成新人类集合的名字是: &quot; + names);
    List&lt;Integer&gt; ages = personList1.stream().map(Person::getAge).collect(Collectors.toList());
    System.out.println(&quot;过滤后生成新人类集合的年龄是: &quot; + ages);
    after();
  }
}

class Person {
  String name;
  Integer age;

  public Person(String name, Integer age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return this.name;
  }

  public Integer getAge() {
    return this.age;
  }
}</code></pre><p>###<strong>3.并行流式数据处理</strong><br>流式处理中的很多都适合采用 分而治之 的思想，从而在处理集合较大时，极大的提高代码的性能，java8的设计者也看到了这一点，所以提供了 并行流式处理。上面的例子中我们都是调用stream()方法来启动流式处理，java8还提供了parallelStream()来启动并行流式处理，parallelStream()本质上基于java7的Fork-Join框架实现，其默认的线程数为宿主机的内核数。</p>
<p>启动并行流式处理虽然简单，只需要将stream()替换成parallelStream()即可，但既然是并行，就会涉及到多线程安全问题，所以在启用之前要先确认并行是否值得（并行的效率不一定高于顺序执行），另外就是要保证线程安全。此两项无法保证，那么并行毫无意义，毕竟结果比速度更加重要</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Roulandu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java8-新特性Lambda表达式与流式编程学习"><span class="nav-number">1.</span> <span class="nav-text">Java8 新特性Lambda表达式与流式编程学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Lambda表达式"><span class="nav-number">1.1.</span> <span class="nav-text">1.Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法："><span class="nav-number">1.1.1.</span> <span class="nav-text">语法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例："><span class="nav-number">1.1.2.</span> <span class="nav-text">实例：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-流式编程"><span class="nav-number">1.2.</span> <span class="nav-text">2.流式编程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roulandu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
